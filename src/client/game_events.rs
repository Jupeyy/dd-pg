use std::{sync::Arc, time::Duration};

use base_io::io::Io;
use client_types::console::ConsoleEntry;
use client_ui::{connecting::user_data::ConnectModes, ingame_menu::server_info::GameServerInfo};
use game_config::config::ConfigGame;
use math::math::vector::luffixed;
use pool::datatypes::StringPool;
use shared_base::network::server_info::ServerInfo;
use shared_network::{game_event_generator::GameEvents, messages::GameMessage};

use base::system::System;
use config::config::ConfigEngine;
use network::network::event::NetworkEvent;
use ui_base::types::UiState;

use crate::game::Game;

pub struct GameEventPipeline<'a> {
    pub client: &'a mut Game,
    pub runtime_thread_pool: &'a mut Arc<rayon::ThreadPool>,
    pub io: &'a Io,
    pub config: &'a mut ConfigEngine,
    pub config_game: &'a mut ConfigGame,
    pub shared_info: &'a Arc<ServerInfo>,
    pub ui: &'a mut UiState,
    pub sys: &'a System,
    pub string_pool: &'a mut StringPool,
    pub console_entries: &'a Vec<ConsoleEntry>,
    pub game_server_info: &'a GameServerInfo,
}

pub struct GameEventsClient {}

impl GameEventsClient {
    pub fn update(pipe: &mut GameEventPipeline<'_>) {
        let event_gen = match pipe.client {
            Game::None | Game::PrepareConnect(_) => None,
            Game::Connecting(game) => Some((
                &game.has_new_events_client,
                &game.game_event_generator_client,
            )),
            Game::Loading(game) => Some((
                &game.has_new_events_client,
                &game.game_event_generator_client,
            )),
            Game::Active(game) | Game::WaitingForFirstSnapshot(game) => Some((
                &game.has_new_events_client,
                &game.game_event_generator_client,
            )),
        };

        if event_gen
            .as_ref()
            .is_some_and(|(has_events, _)| has_events.load(std::sync::atomic::Ordering::Relaxed))
        {
            let (has_events, events) = event_gen.unwrap();
            let mut events_guard = events.events.blocking_lock();
            has_events.store(false, std::sync::atomic::Ordering::Relaxed);
            let events = std::mem::take(&mut *events_guard);
            drop(events_guard);

            for (_, timestamp, event) in events {
                match event {
                    GameEvents::NetworkEvent(net_ev) => match net_ev {
                        NetworkEvent::Connected { .. } => {
                            println!("connect time cl: {}", timestamp.as_nanos());
                        }
                        NetworkEvent::Disconnected { .. } => {
                            pipe.config.ui.path.route("");
                            pipe.ui.is_ui_open = true;
                            *pipe.client = Game::None;
                        }
                        NetworkEvent::NetworkStats(stats) => {
                            if let Game::Active(game) = pipe.client {
                                // Note: we ignore the ping of the connection stats... too unreliable, we use the one
                                // generated by snap/input ack instead.
                                let predict_timing = &mut game.game_data.prediction_timer;
                                predict_timing.add_packet_stats(
                                    timestamp,
                                    stats.packets_sent,
                                    stats.packets_lost,
                                );

                                let byte_stats = &mut game.game_data.net_byte_stats;
                                byte_stats.bytes_per_sec_sent = (byte_stats.bytes_per_sec_sent
                                    * luffixed::from_num(50)
                                    / luffixed::from_num(100))
                                    + luffixed::from_num(
                                        stats.bytes_sent - byte_stats.last_bytes_sent,
                                    ) / luffixed::from_num(
                                        timestamp
                                            .saturating_sub(byte_stats.last_timestamp)
                                            .max(Duration::from_micros(1))
                                            .as_nanos(),
                                    )
                                    .saturating_div(
                                        luffixed::from_num(Duration::from_secs(1).as_nanos()),
                                    ) * luffixed::from_num(50)
                                        / luffixed::from_num(100);
                                byte_stats.bytes_per_sec_recv = (byte_stats.bytes_per_sec_recv
                                    * luffixed::from_num(50)
                                    / luffixed::from_num(100))
                                    + luffixed::from_num(
                                        stats.bytes_recv - byte_stats.last_bytes_recv,
                                    ) / luffixed::from_num(
                                        timestamp
                                            .saturating_sub(byte_stats.last_timestamp)
                                            .max(Duration::from_micros(1))
                                            .as_nanos(),
                                    )
                                    .saturating_div(
                                        luffixed::from_num(Duration::from_secs(1).as_nanos()),
                                    ) * luffixed::from_num(50)
                                        / luffixed::from_num(100);

                                byte_stats.last_timestamp = timestamp;
                                byte_stats.last_bytes_sent = stats.bytes_sent;
                                byte_stats.last_bytes_recv = stats.bytes_recv;
                            }
                        }
                        NetworkEvent::ConnectingFailed(reason) => {
                            if let Game::Connecting(game) = pipe.client {
                                // TODO:
                                game.connect_info.set(ConnectModes::Err { msg: reason });
                            }
                            pipe.config.ui.path.route("connecting");
                        }
                    },
                    GameEvents::NetworkMsg(game_msg) => {
                        match game_msg {
                            GameMessage::ServerToClient(server_to_client_msg) => {
                                pipe.client.on_msg(
                                    timestamp,
                                    server_to_client_msg,
                                    pipe.sys,
                                    pipe.runtime_thread_pool,
                                    pipe.io,
                                    pipe.ui,
                                    pipe.config,
                                    pipe.config_game,
                                    pipe.shared_info,
                                    pipe.string_pool,
                                    pipe.console_entries,
                                    pipe.game_server_info,
                                );
                            }
                            _ => {
                                // ignore any client to server message
                            }
                        }
                    }
                }
            }
        }
    }
}
